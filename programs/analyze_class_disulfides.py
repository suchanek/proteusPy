#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Advanced script for analyzing and visualizing disulfides generated for structural classes.

This script analyzes disulfides generated for specific structural classes using the
DisulfideClassGenerator. It reads class definitions from a CSV file containing
dihedral angle ranges and other metrics for each class. The script performs
statistical analysis on the energy distribution and dihedral angles of the
generated disulfides, identifies the minimum energy conformation, and calculates
the average conformation for a specified class.

Features:
1. Generate disulfides for a specific structural class
2. Analyze and visualize energy distributions with statistical metrics
3. Analyze and visualize dihedral angle distributions
4. Find and save the minimum energy disulfide conformation
5. Calculate and save the average conformation for a class
6. Save generated disulfide lists for further analysis

The CSV file containing class definitions is typically generated by the
DisulfideClass_Analysis.py program in the programs directory.

Author: Eric G. Suchanek, PhD
Last Modification: 2025-03-15
"""

import os
import pickle
import sys

import matplotlib.pyplot as plt
import numpy as np

# Add the parent directory to the Python path to import proteusPy modules
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from proteusPy import Disulfide, DisulfideList
from proteusPy.generate_class_disulfides import DisulfideClassGenerator


def analyze_energy_distribution(disulfide_list: DisulfideList, class_str: str) -> None:
    """
    Analyze and plot the energy distribution of the generated disulfides.

    :param disulfide_list: The list of disulfides to analyze.
    :type disulfide_list: DisulfideList
    :param class_str: The class string representation.
    :type class_str: str
    :return: None
    """
    # Extract energies from all disulfides
    energies = [ss.energy for ss in disulfide_list]

    # Calculate statistics
    min_energy = min(energies)
    max_energy = max(energies)
    mean_energy = np.mean(energies)
    median_energy = np.median(energies)
    std_energy = np.std(energies)

    # Print statistics
    print(f"\nEnergy Statistics for Class {class_str}:")
    print(f"  Minimum Energy: {min_energy:.2f} kcal/mol")
    print(f"  Maximum Energy: {max_energy:.2f} kcal/mol")
    print(f"  Mean Energy: {mean_energy:.2f} kcal/mol")
    print(f"  Median Energy: {median_energy:.2f} kcal/mol")
    print(f"  Standard Deviation: {std_energy:.2f} kcal/mol")

    # Create a histogram of energies
    plt.figure(figsize=(10, 6))
    plt.hist(energies, bins=20, alpha=0.7, color="blue", edgecolor="black")
    plt.axvline(
        mean_energy,
        color="red",
        linestyle="dashed",
        linewidth=2,
        label=f"Mean: {mean_energy:.2f}",
    )
    plt.axvline(
        median_energy,
        color="green",
        linestyle="dashed",
        linewidth=2,
        label=f"Median: {median_energy:.2f}",
    )
    plt.axvline(
        min_energy,
        color="orange",
        linestyle="dashed",
        linewidth=2,
        label=f"Min: {min_energy:.2f}",
    )

    plt.title(f"Energy Distribution for Class {class_str}")
    plt.xlabel("Energy (kcal/mol)")
    plt.ylabel("Frequency")
    plt.legend()
    plt.grid(True, alpha=0.3)

    # Save the plot
    plt.savefig(
        f"class_{class_str}_energy_distribution.png", dpi=300, bbox_inches="tight"
    )
    print(
        f"Saved energy distribution plot to class_{class_str}_energy_distribution.png"
    )

    # Show the plot (comment out if running in a non-interactive environment)
    # plt.show()


def analyze_dihedral_distributions(
    disulfide_list: DisulfideList, class_str: str
) -> None:
    """
    Analyze and plot the distribution of each dihedral angle in the generated disulfides.

    :param disulfide_list: The list of disulfides to analyze.
    :type disulfide_list: DisulfideList
    :param class_str: The class string representation.
    :type class_str: str
    :return: None
    """
    # Extract dihedral angles from all disulfides
    chi1_values = [ss.chi1 for ss in disulfide_list]
    chi2_values = [ss.chi2 for ss in disulfide_list]
    chi3_values = [ss.chi3 for ss in disulfide_list]
    chi4_values = [ss.chi4 for ss in disulfide_list]
    chi5_values = [ss.chi5 for ss in disulfide_list]

    # Create a figure with subplots for each dihedral angle
    fig, axs = plt.subplots(5, 1, figsize=(10, 15), sharex=True)

    # Plot histograms for each dihedral angle
    axs[0].hist(chi1_values, bins=20, alpha=0.7, color="blue", edgecolor="black")
    axs[0].set_title("Chi1 Distribution")
    axs[0].grid(True, alpha=0.3)

    axs[1].hist(chi2_values, bins=20, alpha=0.7, color="green", edgecolor="black")
    axs[1].set_title("Chi2 Distribution")
    axs[1].grid(True, alpha=0.3)

    axs[2].hist(chi3_values, bins=20, alpha=0.7, color="red", edgecolor="black")
    axs[2].set_title("Chi3 Distribution")
    axs[2].grid(True, alpha=0.3)

    axs[3].hist(chi4_values, bins=20, alpha=0.7, color="purple", edgecolor="black")
    axs[3].set_title("Chi4 Distribution")
    axs[3].grid(True, alpha=0.3)

    axs[4].hist(chi5_values, bins=20, alpha=0.7, color="orange", edgecolor="black")
    axs[4].set_title("Chi5 Distribution")
    axs[4].set_xlabel("Angle (degrees)")
    axs[4].grid(True, alpha=0.3)

    # Add a common y-label
    fig.text(0.04, 0.5, "Frequency", va="center", rotation="vertical", fontsize=12)

    # Add a main title
    fig.suptitle(f"Dihedral Angle Distributions for Class {class_str}", fontsize=16)
    plt.tight_layout(rect=[0.05, 0, 1, 0.97])

    # Save the plot
    plt.savefig(
        f"class_{class_str}_dihedral_distributions.png", dpi=300, bbox_inches="tight"
    )
    print(
        f"Saved dihedral distributions plot to class_{class_str}_dihedral_distributions.png"
    )

    # Show the plot (comment out if running in a non-interactive environment)
    # plt.show()


def find_minimum_energy_disulfide(disulfide_list: DisulfideList) -> Disulfide:
    """
    Find the disulfide with the minimum energy in the list.

    :param disulfide_list: The list of disulfides to search.
    :type disulfide_list: DisulfideList
    :return: The disulfide with the minimum energy.
    :rtype: Disulfide
    """
    min_energy_disulfide = min(disulfide_list, key=lambda ss: ss.energy)
    return min_energy_disulfide


def main():
    """
    Main function demonstrating advanced analysis of generated disulfides.

    This function:
    1. Initializes a DisulfideClassGenerator with a CSV file of class metrics
    2. Generates disulfides for a specific class (default: "+++++", RH Spiral)
    3. Analyzes energy and dihedral angle distributions
    4. Finds and saves the minimum energy disulfide
    5. Calculates and saves the average conformation
    6. Saves the complete disulfide list for further analysis

    :return: None
    """
    # Path to the CSV file
    csv_file = "~/repos/proteusPy/octant_class_metrics_0.04.csv"
    generator = DisulfideClassGenerator(csv_file)

    # Select a class to analyze
    class_str = "22222"  # The "+++++" class (RH Spiral)

    print(f"Generating and analyzing disulfides for class {class_str}...")

    # Generate disulfides for the class
    disulfide_list = generator.generate_for_class(class_str, use_class_str=False)

    if disulfide_list:
        # Get the class string representation

        print(f"Generated {len(disulfide_list)} disulfides for class {class_str}.")

        # Analyze the energy distribution
        analyze_energy_distribution(disulfide_list, class_str)

        # Analyze the dihedral angle distributions
        # analyze_dihedral_distributions(disulfide_list, class_str)

        # Find the disulfide with the minimum energy
        min_energy_disulfide = find_minimum_energy_disulfide(disulfide_list)

        print("\nDisulfide with Minimum Energy:")
        print(f"  Name: {min_energy_disulfide.name}")
        print(f"  Dihedrals: {min_energy_disulfide.dihedrals}")
        print(f"  Energy: {min_energy_disulfide.energy:.2f} kcal/mol")
        print(f"  Torsion length: {min_energy_disulfide.torsion_length:.2f}")
        print(f"  Cα distance: {min_energy_disulfide.ca_distance:.2f} Å")

        # Save the minimum energy disulfide to a separate file
        min_energy_file = f"class_{class_str}_min_energy_disulfide.pkl"
        with open(min_energy_file, "wb") as f:
            pickle.dump(min_energy_disulfide, f)
        print(f"Saved minimum energy disulfide to {min_energy_file}.")

        # Visualize the minimum energy disulfide (uncomment to use)
        # Note: This requires a graphical environment
        # min_energy_disulfide.display(style='sb', light="auto")

        # Save a screenshot of the minimum energy disulfide (uncomment to use)
        # min_energy_disulfide.screenshot(style='sb', fname=f'class_{class_id}_min_energy_disulfide.png')

        # Save the entire disulfide list to a file
        output_file = f"class_{class_str}_disulfides.pkl"
        with open(output_file, "wb") as f:
            pickle.dump(disulfide_list, f)
        print(f"Saved all disulfides to {output_file}.")

        # Additional analysis: Calculate average conformation
        avg_conformation = disulfide_list.average_conformation
        print(f"\nAverage Conformation for Class {class_str}:")
        print(f"  Dihedrals: {avg_conformation}")

        # Create a disulfide with the average conformation
        avg_disulfide = Disulfide(name=f"{class_str}_avg", torsions=avg_conformation)
        print(f"  Energy: {avg_disulfide.energy:.2f} kcal/mol")
        print(f"  Cα distance: {avg_disulfide.ca_distance:.2f} Å")

        # Save the average conformation disulfide
        avg_file = f"class_{class_str}_avg_conformation_disulfide.pkl"
        with open(avg_file, "wb") as f:
            pickle.dump(avg_disulfide, f)
        print(f"Saved average conformation disulfide to {avg_file}.")
        disulfide_list.display_overlay(light="auto")
    else:
        print(f"Class {class_str} not found. Let's try with '+++++' instead.")


if __name__ == "__main__":
    main()
